% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rjmcmcMethod.R
\name{rjmcmcCHR}
\alias{rjmcmcCHR}
\title{Start rjmcmc with n cores after Split a \code{GRanges} containing
reads in a list of smaller segments for the \code{rjmcmc} function.}
\usage{
rjmcmcCHR(dataIP, zeta = 147, delta, maxLength, nbrIterations, kMax,
  lambda = 3, minInterval, maxInterval, minReads = 5,
  adaptIterationsToReads = TRUE, vSeed = -1, nbCores = 1,
  dirOut = "out", saveAsRDS = FALSE, saveSEG = TRUE)
}
\arguments{
\item{dataIP}{a \code{GRanges}, the reads that need to be segmented.}

\item{zeta}{a positive \code{integer} or \code{numeric}, the length
of the nucleosomes. Default: 147.}

\item{delta}{a positive \code{integer} or \code{numeric}, the accepted
range of overlapping section between segments. The overlapping section
being \code{zeta} + \code{delta}.}

\item{maxLength}{a positive \code{integer} or \code{numeric}, the
length of each segment.}

\item{nbrIterations}{a positive \code{integer} or \code{numeric}, the
number of iterations. Non-integer values of
\code{nbrIterations} will be casted to \code{integer} and truncated towards
zero.}

\item{kMax}{a positive \code{integer} or \code{numeric}, the maximum number
of degrees of freedom per region. Non-integer values
of \code{kMax} will be casted to \code{integer} and truncated towards zero.}

\item{lambda}{a positive \code{numeric}, the theorical mean
of the Poisson distribution. Default: 3.}

\item{minInterval}{a \code{numeric}, the minimum distance between two
nucleosomes.}

\item{maxInterval}{a \code{numeric}, the maximum distance between two
nucleosomes.}

\item{minReads}{a positive \code{integer} or \code{numeric}, the minimum
number of reads in a potential canditate region. Non-integer values
of \code{minReads} will be casted to \code{integer} and truncated towards
zero. Default: 5.}

\item{adaptIterationsToReads}{a \code{logical} indicating if the number
of iterations must be modified in function of the number of reads.
Default: \code{TRUE}.}

\item{vSeed}{a \code{integer}. A seed used when reproducible results are
needed. When a value inferior or equal to zero is given, a random integer
is used. Default: -1.}

\item{nbCores}{a positive \code{integer}, the number
of core use in parallel. Default: 1.}

\item{dirOut}{a \code{character} string. The name of the directory
where 2 directory are create (if they don't exists).
The directory dirOut/results contents the rjmcmc results of each segment.
The directory dirOut/done contents file in RData format the log file
of each segment. If the file for the segment is in the directory
the program past to the next segment.
 Default: "out".}

\item{saveAsRDS}{a \code{logical}. When \code{TRUE}, a RDS file containing
the complete output of the c++ rjmcmc() function is created.
Default : \code{FALSE}.}

\item{saveSEG}{a \code{logical}. When \code{TRUE}, a RDS file containing
the segments generated by  \code{\link{segmentation}} function is
saved in dirOut.
Default : \code{FALSE}.}
}
\value{
a \code{list} the k, the mu , the muPost .
}
\description{
Split a \code{GRanges} of reads (as example, the reads from
a chromosome) in a \code{list} of smaller \code{GRanges} sot that the
\code{rjmcmc} function can be run on each segments.
}
\examples{

## Load synthetic dataset of reads
data(syntheticNucleosomeReads)

## Use dataset of reads to create GRanges object
sampleGRanges <- GRanges(seqnames = syntheticNucleosomeReads$dataIP$chr,
    ranges = IRanges(start = syntheticNucleosomeReads$dataIP$start,
    end = syntheticNucleosomeReads$dataIP$end),
    strand = syntheticNucleosomeReads$dataIP$strand)


\dontrun{result <- rjmcmcCHR(dataIP=sampleGRanges, zeta = 147,
             delta=50, maxLength=1200,
             nbrIterations = 1000, lambda = 3, kMax = 30,
             minInterval = 146, maxInterval = 292, minReads = 5,
             vSeed = 10113, saveAsRDS = FALSE)}


}
\author{
Pascal Belleau, Astrid Deschenes
}

